---
description: 
globs: 
alwaysApply: true
---
# Backend Structure & Architecture (.NET 9 / C# 12)

- **Architecture:** Strictly adhere to Clean Architecture principles. Maintain clear boundaries between Domain, Application, Infrastructure, and Presentation (API) layers. Dependencies must point inwards.
- **Domain-Driven Design (DDD):** Model the core business logic within the Domain layer using Entities, Value Objects, Aggregates, Repositories (interfaces), and Domain Services where applicable. Encapsulate business rules within domain objects.
- **Application Layer:** Orchestrate use cases using Application Services or CQRS handlers (MediatR). Define Data Transfer Objects (DTOs) with `Request` or `Response` posfixes. // ******* Define Repository interfaces here (to be implemented in Infrastructure).
- **Infrastructure Layer:** Implement external concerns like database access (EF Core implementations of Repositories), external API calls (Refit clients), authentication services, logging, etc.
- **Presentation Layer (API):** Implement API controllers using standard ASP.NET Core Controller Endpoints. Keep controllers thin, delegating work to the Application layer (e.g., via MediatR). Handle request/response mapping and model validation.
- **Data Access (EF Core):**
    - Use EF Core for interacting with the PostgreSQL database.
    - Define `DbContext` within the Infrastructure layer.
    - Configure entities using Fluent API (`IEntityTypeConfiguration<T>`) within the Infrastructure layer.
    - Implement Repository patterns defined in the Application/Domain layer.
    - Use `async`/`await` for all database operations.
    - Manage migrations using EF Core Migrations.
- **Mapping:** Use manual mapping methods (e.g., static extension methods, dedicated mapper classes) to map between Domain Entities, DTOs, and persistence models. Avoid direct exposure of Domain Entities through the API.
- **Identifiers:** Use `Ulid` for primary keys of entities unless a different type is explicitly required (e.g., for external system compatibility).
- **API Clients (Refit):** Define Refit interfaces in the Application or Infrastructure layer (depending on usage context) to interact with external HTTP APIs. Configure Refit using `HttpClientFactory`.
- **CQRS (MediatR):** Use MediatR for implementing the CQRS pattern within the Application layer. Define Commands, Queries, and their respective Handlers. Inject `ISender` into controllers/services to dispatch requests.
- **Result Handling (FluentResults):**
    - All Application layer service methods/handlers that can fail should return `Result` or `Result<T>`.
    - Avoid throwing exceptions for expected business rule violations or validation errors. Use `Result.Fail()` with appropriate error messages/codes.
    - Define application-specific error codes in dedicated `*ErrorCodes.cs` files. Use uppercase snake_case (e.g., `IDENTITY_ROLE_NOT_FOUND`).
    - Use the provided `CustomFluentError` structure: `new CustomFluentError("ERROR_CODE", "User-friendly error message.");`
    - Check for existing error codes before adding new ones. Do not use codes not defined in an `ErrorCodes.cs` file.
    - Map `Result` objects to appropriate HTTP status codes in the API layer (e.g., using middleware or action filters).
- **Authentication/Authorization (Keycloak):**
    - Configure JWT Bearer authentication using `Microsoft.AspNetCore.Authentication.JwtBearer` to validate tokens issued by Keycloak.
    - Use `Keycloak.Net.Core` for administrative interactions with Keycloak if needed (e.g., user management from the backend).
    - Apply authorization policies and attributes (`[Authorize]`) to secure endpoints.
- **API Versioning:** Implement API versioning using `Asp.Versioning.Mvc`. Use a consistent versioning scheme (e.g., URL path versioning `/api/v1/...`).
- **API Documentation:** Use Swashbuckle to generate OpenAPI documentation. Ensure controllers, actions, and DTOs have appropriate XML documentation comments (`<summary>`, `<param>`, `<returns>`) for clear documentation.
- **Configuration:** Use strongly-typed configuration (`IOptions<T>`, `IConfiguration`) bound from `appsettings.json`, environment variables, etc.
- **Middleware:** Use ASP.NET Core middleware for cross-cutting concerns like exception handling, logging, request correlation, security headers, and potentially mapping `Result` failures to HTTP responses.
- **Background Tasks:** Use `BackgroundService` for long-running or scheduled tasks.
- **REST APIs:** Use Level 2 maturity level for REST API design, use `HTTP Verbs` inside the Controllers for every controller.
- **Property setters:** All domain entity properties must use `get; private set;` (no public setters) to enforce invariants and encapsulation except `Id` properties which can be public.
- **Migrations (EFÂ Core CLI):**
    - **Create a new migration** 
      `dotnet ef migrations add <MigrationName> --project src/KosHome.Infrastructure --startup-project src/KosHome.Api`
    - **Apply migrations / update the database**  
      `dotnet ef database update --project src/KosHome.Infrastructure --startup-project src/KosHome.Api`.
    - **Migration file immutability:** Strictly **do not edit** generated migration files. If changes are needed, either adjust your model before generating a new migration or create a new migration to apply fixes.
- **Return Failures:** When using `Result.Fail(<error>)` always use the appropriate error codes inside `src/KosHome.Domain/Common/<EntityName>Errors.cs>` classes. Check for existing error codes that can be used before adding new ones. 
Never use codes not defined in an `ErrorCodes.cs` file. Each entity has its own `<EntityName>Errors.cs` file ex: `src/KosHome.Domain/Common/CitiesErrors.cs`.
